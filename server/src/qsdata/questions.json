{"amountThousandthsFormat":{"answermd":"### 方法一\n\n正则表达式\n\n```js\nexport default function amountThousandthsFormat(amount) {\n  return amount.replace(/(?<!\\.\\d*)\\B(?=(?:\\d{3})+\\b)/, ',');\n}\n```\n","introduce":"金额千分位格式化\n\n用例 1:\n\n```js\nconst amount = '314';\nconst formatAmount = amountThousandthsFormat(amount);\n\nconsole.log(formatAmount); // '314'\n```\n\n用例 2:\n\n```js\nconst amount = '31415926';\nconst formatAmount = amountThousandthsFormat(amount);\n\nconsole.log(formatAmount); // '3,415,926'\n```\n\n用例 3:\n\n```js\n// 带小数位\nconst amount = '31415926.62';\nconst formatAmount = amountThousandthsFormat(amount);\n\nconsole.log(formatAmount); // '3,415,926.62'\n```\n\n用例 4:\n\n```js\n// 带长小数位\nconst amount = '31415926.629514';\nconst formatAmount = amountThousandthsFormat(amount);\n\nconsole.log(formatAmount); // '3,415,926.629514'\n```\n","desc":"金额千分位格式化","index":"/**\n * 金额千分位格式化\n *\n * @param {*} amount\n * @return {*}\n */\nexport default function amountThousandthsFormat(amount) {\n  return amount;\n}\n","test":"import assert from 'assert';\nimport _deepClone from './answer.mjs';\nimport f from './index.mjs';\n\nconst circle1 = { foo: 1 };\nconst circle2 = { bar: 2, c1: circle1 };\ncircle1.c2 = circle2;\n\nconst cases = [\n  {\n    Input: '314',\n    Expected: '314',\n    Message: '314 原样输出',\n  },\n  {\n    Input: '31415926',\n    Expected: '31,415,926',\n    Message: '输入 31415926 输出 3,1415,926',\n  },\n  {\n    Input: '31415926.62',\n    Expected: '31,415,926.62',\n    Message: '带小数位: 输入 31415926.62 输出 31,415,926.62',\n  },\n  {\n    Input: '31415926.629514',\n    Expected: '31,415,926.629514',\n    Message: '带长小数位: 输入 31415926.629514 输出 31,415,926.629514',\n  },\n];\n\n(function () {\n  for (let i = 0; i < cases.length; i++) {\n    const { Input, Expected, Message } = cases[i];\n\n    let output;\n    try {\n      output = f(Input);\n      assert.deepEqual(output, Expected);\n    } catch (error) {\n      console.log('用例 ' + String(i + 1) + ': ' + Message + ' 未通过 ×');\n      if (error.code === 'ERR_ASSERTION') {\n        console.log('Input:', JSON.stringify(Input));\n        console.log('Expected:', JSON.stringify(error.expected));\n        console.log('Received:', JSON.stringify(output));\n      } else {\n        console.log(error);\n      }\n      break;\n    }\n\n    console.log('用例 ' + String(i + 1) + ': ' + Message + ' 通过 √');\n  }\n})();\n"},"curry":{"answermd":"### 方法一\n\n```js\nexport default function currying(fn) {\n  let _args = [];\n  return (...args) => {\n    let result = null;\n    if (args.length) {\n      _args = _args.concat(args);\n    } else {\n      result = fn(..._args);\n    }\n    return result;\n  };\n}\n```\n","introduce":"实现一个柯里化函数\n\n未传递参数时真正调用\n\n用例 1:\n\n```js\nconst add = (...args) => args.reduce((a, b) => a + b, 0);\n\n// 输入 [add, [1], [2], [3], null]\n\n// 执行\nconst curryAdd = currying(add); // true\ncurryAdd(1); // null\ncurryAdd(2); // null\ncurryAdd(3); // null\ncurryAdd(); // 6\n\n// [true, null, null, null, 6]\n```\n\n用例 2:\n\n```js\nconst add = (...args) => args.reduce((a, b) => a + b, 0);\n\n// 输入 [add, [1, 2, 1], null, null, null]\nconst curryAdd = currying(add); // true\ncurryAdd(1, 2, 1); // null\ncurryAdd(); // 4\ncurryAdd(); // 4\ncurryAdd(); // 4\n\n// [true, null, 4, 4, 4]\n```\n\n用例 3:\n\n```js\nconst add = (...args) => args.reduce((a, b) => a + b, 0);\n\n// 输入 [add, [1, 2, 1], null, [1, 2], null]\nconst curryAdd = currying(add); // true\ncurryAdd(1, 2, 1); // null\ncurryAdd(); // 4\ncurryAdd(1, 2); // null\ncurryAdd(); // 7\n\n// [true, null, 4, null, 7]\n```\n\n用例 4:\n\n```js\nconst multi = (...args) => args.reduce((a, b) => a * b, 1);\n\n// 输入 [multi, [100], null, [1, 2], null]\nconst curryMulti = currying(multi);\ncurryMulti(100); // null\ncurryMulti(); // 100\ncurryMulti(1, 2); // null\ncurryMulti(); // 200\n// [true, null, 100, null, 200]\n```\n","desc":"实现一个柯里化函数","index":"/**\n * 柯里化函数\n *\n * @export\n * @param {Function} fn\n * @return {Function}\n */\nexport default function currying(fn) {\n  return fn;\n}\n","test":"import assert from 'assert';\nimport f from './index.mjs';\n\nconst add = (...args) => args.reduce((a, b) => a + b, 0);\nconst multi = (...args) => args.reduce((a, b) => a * b, 1);\n\nconst cases = [\n  {\n    Input: [add, [1], [2], [3], null],\n    Expected: [true, null, null, null, 6],\n    Message: '加法函数柯里化一',\n  },\n  {\n    Input: [add, [1, 2, 1], null, null, null],\n    Expected: [true, null, 4, 4, 4],\n    Message: '加法函数柯里化二',\n  },\n  {\n    Input: [add, [1, 2, 1], null, [1, 2], null],\n    Expected: [true, null, 4, null, 7],\n    Message: '加法函数柯里化三',\n  },\n  {\n    Input: [multi, [100], null, [1, 2], null],\n    Expected: [true, null, 100, null, 200],\n    Message: '乘法函数柯里化一',\n  },\n];\n\n(function () {\n  for (let i = 0; i < cases.length; i++) {\n    const { Input, Expected, Message } = cases[i];\n    const output = [];\n    try {\n      let curry;\n      Input.forEach((arg) => {\n        let result;\n        if (!curry) {\n          curry = f(arg);\n          result = !!curry;\n        } else if (arg) {\n          result = curry(...arg);\n        } else {\n          result = curry();\n        }\n        output.push(result);\n      });\n\n      assert.deepEqual(output, Expected);\n    } catch (error) {\n      console.log('用例 ' + String(i + 1) + ': ' + Message + ' 未通过');\n      if (error.code === 'ERR_ASSERTION') {\n        console.log('Input:', Input);\n        console.log('Expected:', JSON.stringify(error.expected));\n        console.log('Received:', JSON.stringify(output));\n      } else {\n        console.log(error);\n      }\n      break;\n    }\n    console.log('用例 ' + String(i + 1) + ': ' + Message + ' 通过');\n  }\n})();\n"},"deepClone":{"answermd":"### 方法一\n\n递归拷贝, 使用 weakMap 过滤循环引用\n\n```js\nexport default function deepClone(obj, weakMap = new WeakMap()) {\n  const type = Object.prototype.toString.call(obj);\n  if (!(type === '[object Object]' || type === '[object Array]')) return obj;\n  const o = type === '[object Object]' ? {} : [];\n  if (weakMap.get(obj)) return o;\n  weakMap.set(obj, true);\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      o[key] = deepClone(obj[key], weakMap);\n    }\n  }\n  return o;\n}\n```\n","introduce":"实现对象深拷贝, 修改深拷贝对象不影响原对象\n\n用例 1:\n\n```js\nconst userList = { user: [{ name: 'xjq' }] };\nconst cloneUserList = deepClone(userList);\n\nconsole.log(cloneUserList); // { user: [{ name: 'xjq' }] }\ncloneUserList.user.push({ name: 'xjq1' });\nconsole.log(cloneUserList.user); // [{ name:'xjq' }]\n```\n\n用例 2:\n\n```js\n\nconst user = { name: 'xjq', height: 180 };\nconst cloneUser = deepClone(user);\n\nconsole.log(user); // { name: 'xjq', height: 180 }\n\ndelete cloneUser.height;\nconsole.log(cloneUser); // { name: 'xjq' }\nconsole.log(user; // { name: 'xjq', height: 180 }\n```\n","desc":"实现对象深拷贝, 修改深拷贝对象不影响原对象","index":"/**\n * 深拷贝\n *\n * @param {(Array|Object)} obj\n * @return {(Array|Object)}\n */\nexport default function deepClone(obj) {\n  return {};\n}\n","test":"import assert from 'assert';\nimport _deepClone from './answer.mjs';\nimport f from './index.mjs';\n\nconst circle1 = { foo: 1 };\nconst circle2 = { bar: 2, c1: circle1 };\ncircle1.c2 = circle2;\n\nconst cases = [\n  {\n    Input: [{ f: 1 }],\n    Expected: [{ f: 1 }],\n    Message: '一层对象',\n  },\n  {\n    Input: [1, 2, { a: 1 }],\n    Expected: [1, 2, { a: 1 }],\n    Message: '两层对象',\n  },\n  {\n    Input: { b: [{ c: 1, d: [{ d: 1, f: 2 }] }] },\n    Expected: { b: [{ c: 1, d: [{ d: 1, f: 2 }] }] },\n    Message: '两层对象, 且修改返回值属性',\n    callback: function (i) {\n      const originInput = _deepClone(this.Input);\n      try {\n        const output = f(this.Input);\n        output['1'] = Math.random();\n        assert.deepEqual(this.Input, originInput);\n        return true;\n      } catch (error) {\n        if (error.code === 'ERR_ASSERTION') {\n          console.log(\n            '用例 ' + String(i + 1) + ': ' + this.Message + ' 未通过 ×'\n          );\n          console.log(\n            '修改输出对象属性后的输入对象: ',\n            JSON.stringify(this.Input)\n          );\n          console.log('原输入对象: ', JSON.stringify(originInput));\n        } else {\n          console.log(error);\n        }\n      }\n    },\n  },\n  {\n    Input: circle1,\n    Expected: { foo: 1, c2: { bar: 2, c1: {} } },\n    Message: '存在循环引用',\n    callback: function (i) {\n      try {\n        const output = f(this.Input);\n        assert.deepEqual(output, this.Expected);\n        return true;\n      } catch (error) {\n        console.log(\n          '用例 ' + String(i + 1) + ': ' + this.Message + ' 未通过 ×'\n        );\n        console.log(error);\n      }\n    },\n  },\n];\n\n(function () {\n  for (let i = 0; i < cases.length; i++) {\n    const { Input, Expected, Message, callback } = cases[i];\n    if (callback) {\n      if (!cases[i].callback(i)) {\n        break;\n      }\n    } else {\n      let output;\n      try {\n        output = f(Input);\n        assert.deepEqual(output, Expected);\n      } catch (error) {\n        console.log('用例 ' + String(i + 1) + ': ' + Message + ' 未通过 ×');\n        if (error.code === 'ERR_ASSERTION') {\n          console.log('Input:', JSON.stringify(Input));\n          console.log('Expected:', JSON.stringify(error.expected));\n          console.log('Received:', JSON.stringify(output));\n        } else {\n          console.log(error);\n        }\n        break;\n      }\n    }\n\n    console.log('用例 ' + String(i + 1) + ': ' + Message + ' 通过 √');\n  }\n})();\n"},"flatten":{"answermd":"### 方法一\n\n```js\nexport default function flatten(arr) {\n  return arr.reduce((acc, cur) => {\n    if (Array.isArray(cur)) {\n      acc = acc.concat(flatten(cur));\n    } else {\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n}\n```\n","introduce":"实现数组扁平化方法\n\n用例 1:\n\n```js\nflatten([1, 2, 3]); // [1, 2, 3]\n```\n\n用例 2:\n\n```js\nflatten([1, [2, 3]]); // [1, 2, 3]\n```\n\n用例 3:\n\n```js\nflatten([1, [[2, 2], [3, [4]], 5]]); // [1, 2, 2, 3, 4, 5];\n```\n","desc":"实现数组扁平化方法","index":"/**\n * 数组扁平化\n *\n * @param {number[]} arr\n * @return {number[]}\n */\nexport default function flatten(arr) {\n  return [];\n}\n","test":"import assert from 'assert';\nimport f from './index.mjs';\n\nconst cases = [\n  {\n    Input: [1, 2, 3],\n    Expected: [1, 2, 3],\n    Message: '一层数组',\n  },\n  {\n    Input: [1, [2, 3]],\n    Expected: [1, 2, 3],\n    Message: '两层数组',\n  },\n  {\n    Input: [1, [[2, 2], [3, [4]], 5]],\n    Expected: [1, 2, 2, 3, 4, 5],\n    Message: '四层数组',\n  },\n];\n\n(function () {\n  for (let i = 0; i < cases.length; i++) {\n    const { Input, Expected, Message } = cases[i];\n    let output;\n    try {\n      output = f(Input);\n      assert.deepEqual(output, Expected);\n    } catch (error) {\n      console.log('用例 ' + String(i + 1) + ': ' + Message + ' 未通过 ×');\n      if (error.code === 'ERR_ASSERTION') {\n        console.log('Input:', JSON.stringify(Input));\n        console.log('Expected:', JSON.stringify(error.expected));\n        console.log('Received:', JSON.stringify(output));\n      } else {\n        console.log(error);\n      }\n      break;\n    }\n    console.log('用例 ' + String(i + 1) + ': ' + Message + ' 通过 √');\n  }\n})();\n"},"sort":{"answermd":"### 方法一\n\n原生 api sort 方法\n\n```js\nexport default function sort(arr) {\n  // js api\n  return arr.sort();\n}\n```\n","introduce":"将数组按从小到大的顺序排序\n\n输入为 数字数组\n\n- 冒泡排序\n- 选择排序\n- 插入排序\n- 归并排序\n- 堆排序\n- 快速排序\n\n...\n\n用例 1:\n\n```js\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconst sortArr = sort(arr);\n\nconsole.log(sortArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n用例 2:\n\n```js\nconst arr = [1, 9, 2, 4, 3, 7, 6, 8, 6];\nconst sortArr = sort(arr);\n\nconsole.log(sortArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n用例 3:\n\n```js\nconst arr = [1, 1, 1, 3, 4, 5, 7, 6, 6, 6, 0, 0, -1];\nconst sortArr = sort(arr);\n\nconsole.log(sortArr); // [-1, 0, 0, 1, 1, 1, 3, 4, 5, 6, 6, 6, 7]\n```\n","desc":"将数组按从小到大的顺序排序","index":"/**\n * 排序函数\n *\n * @export\n * @param {number[]} arr\n * @return {number[]}\n */\nexport default function sort(arr) {\n  return [];\n}\n","test":"import assert from 'assert';\nimport f from './index.mjs';\n\nconst cases = [\n  {\n    Input: [],\n    Expected: [],\n    Message: '空数组',\n  },\n  {\n    Input: [1, 2, 3, 4, 5, 6, 7, 8, 9],\n    Expected: [1, 2, 3, 4, 5, 6, 7, 8, 9],\n    Message: '已排序好的数组',\n  },\n  {\n    Input: [1, 9, 2, 4, 3, 7, 6, 8, 5],\n    Expected: [1, 2, 3, 4, 5, 6, 7, 8, 9],\n    Message: '乱序数组一',\n  },\n  {\n    Input: [1, 1, 1, 3, 4, 5, 7, 6, 6, 6, 0, 0, -1],\n    Expected: [-1, 0, 0, 1, 1, 1, 3, 4, 5, 6, 6, 6, 7],\n    Message: '乱序数组二-包含负数',\n  },\n];\n\n(function () {\n  for (let i = 0; i < cases.length; i++) {\n    const { Input, Expected, Message } = cases[i];\n    let output;\n    try {\n      output = f(Input);\n      assert.deepEqual(output, Expected);\n    } catch (error) {\n      console.log('用例 ' + String(i + 1) + ': ' + Message + ' 未通过');\n      if (error.code === 'ERR_ASSERTION') {\n        console.log('Input:', JSON.stringify(Input));\n        console.log('Expected:', JSON.stringify(error.expected));\n        console.log('Received:', JSON.stringify(output));\n      } else {\n        console.log(error);\n      }\n      break;\n    }\n    console.log('用例 ' + String(i + 1) + ': ' + Message + ' 通过');\n  }\n})();\n"},"unique":{"answermd":"### 方法一\n\n利用 set 去除\n\n```js\nexport default function unique(arr) {\n  return [...new Set(arr)];\n}\n```\n","introduce":"数组去重\n\n用例 1:\n\n```js\nconst arr = [1, 2, 3];\nconst uniqueArr = unique(arr1);\n\nconsole.log(uniqueArr); // [1, 2, 3]\n```\n\n用例 2:\n\n```js\nconst arr = [1, 2, 3, 3, 3];\nconst uniqueArr = unique(arr);\n\nconsole.log(uniqueArr); // [1, 2, 3]\n```\n","desc":"数组去重","index":"/**\n * 数组去重\n *\n * @export\n * @param {number[]} arr\n * @return {number[]}\n */\nexport default function unique(arr) {\n  return [];\n}\n","test":"import assert from 'assert';\nimport f from './index.mjs';\n\nconst cases = [\n  {\n    Input: [1, 2, 3],\n    Expected: [1, 2, 3],\n    Message: '无重复数字',\n  },\n  {\n    Input: [1, 2, 3, 3],\n    Expected: [1, 2, 3],\n    Message: '单个重复数字',\n  },\n  {\n    Input: [1, 1, 2, 2, 2, 3, 3],\n    Expected: [1, 2, 3],\n    Message: '多个重复数字',\n  },\n];\n\n(function () {\n  for (let i = 0; i < cases.length; i++) {\n    const { Input, Expected, Message } = cases[i];\n    let output;\n    try {\n      output = f(Input);\n      assert.deepEqual(output, Expected);\n    } catch (error) {\n      console.log('用例 ' + String(i + 1) + ': ' + Message + ' 未通过');\n      if (error.code === 'ERR_ASSERTION') {\n        console.log('Input:', JSON.stringify(Input));\n        console.log('Expected:', JSON.stringify(error.expected));\n        console.log('Received:', JSON.stringify(output));\n      } else {\n        console.log(error);\n      }\n      break;\n    }\n    console.log('用例 ' + String(i + 1) + ': ' + Message + ' 通过');\n  }\n})();\n"}}