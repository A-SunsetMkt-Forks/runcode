{"amountThousandthsFormat":{"answer":"export default function f(amount) {\n  return amount.replace(/(?<!\\.\\d*)\\B(?=(?:\\d{3})+\\b)/, ',');\n}\n","introduce":"## AmountThousandthsFormat\n\n金额千分位格式化\n\n用例 1:\n\n```js\nconst amount = '314';\nconst formatAmount = amountThousandthsFormat(amount);\n\nconsole.log(formatAmount); // '314'\n```\n\n用例 2:\n\n```js\nconst amount = '31415926';\nconst formatAmount = amountThousandthsFormat(amount);\n\nconsole.log(formatAmount); // '3,415,926'\n```\n\n用例 3:\n\n```js\n// 带小数位\nconst amount = '31415926.62';\nconst formatAmount = amountThousandthsFormat(amount);\n\nconsole.log(formatAmount); // '3,415,926.62'\n```\n\n用例 4:\n\n```js\n// 带长小数位\nconst amount = '31415926.629514';\nconst formatAmount = amountThousandthsFormat(amount);\n\nconsole.log(formatAmount); // '3,415,926.629514'\n```\n","desc":"金额千分位格式化","index":"/**\n * 金额千分位格式化\n *\n * @param {*} amount\n * @return {*}\n */\nexport default function amountThousandthsFormat(amount) {\n  return amount.replace(/(?<!\\.\\d*)\\B(?=(?:\\d{3})+\\b)/g, ',');\n}\n","test":"import assert from 'assert';\nimport _deepClone from './answer.mjs';\nimport f from './index.mjs';\n\nconst circle1 = { foo: 1 };\nconst circle2 = { bar: 2, c1: circle1 };\ncircle1.c2 = circle2;\n\nconst cases = [\n  {\n    Input: '314',\n    Expected: '314',\n    Message: '314 原样输出',\n  },\n  {\n    Input: '31415926',\n    Expected: '31,415,926',\n    Message: '输入 31415926 输出 3,1415,926',\n  },\n  {\n    Input: '31415926.62',\n    Expected: '31,415,926.62',\n    Message: '带小数位: 输入 31415926.62 输出 31,415,926.62',\n  },\n  {\n    Input: '31415926.629514',\n    Expected: '31,415,926.629514',\n    Message: '带长小数位: 输入 31415926.629514 输出 31,415,926.629514',\n  },\n];\n\n(function () {\n  for (let i = 0; i < cases.length; i++) {\n    const { Input, Expected, Message } = cases[i];\n\n    let output;\n    try {\n      output = f(Input);\n      assert.deepEqual(output, Expected);\n    } catch (error) {\n      console.log('用例 ' + String(i + 1) + ': ' + Message + ' 未通过 ×');\n      if (error.code === 'ERR_ASSERTION') {\n        console.log('Input:', JSON.stringify(Input));\n        console.log('Expected:', JSON.stringify(error.expected));\n        console.log('Received:', JSON.stringify(output));\n      } else {\n        console.log(error);\n      }\n      break;\n    }\n\n    console.log('用例 ' + String(i + 1) + ': ' + Message + ' 通过 √');\n  }\n})();\n"},"deepClone":{"answer":"export default function deepClone(obj, weakMap = new WeakMap()) {\n  const type = Object.prototype.toString.call(obj);\n  if (!(type === '[object Object]' || type === '[object Array]')) return obj;\n  const o = type === '[object Object]' ? {} : [];\n  if (weakMap.get(obj)) return o;\n  weakMap.set(obj, true);\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      o[key] = deepClone(obj[key], weakMap);\n    }\n  }\n  return o;\n}\n","introduce":"## DeepClone\n\n实现对象深拷贝, 修改深拷贝对象不影响原对象\n\n用例 1:\n\n```js\nconst userList = { user: [{ name: 'xjq' }] };\nconst cloneUserList = deepClone(userList);\n\nconsole.log(cloneUserList); // { user: [{ name: 'xjq' }] }\ncloneUserList.user.push({ name: 'xjq1' });\nconsole.log(cloneUserList.user); // [{ name:'xjq' }]\n```\n\n用例 2:\n\n```js\n\nconst user = { name: 'xjq', height: 180 };\nconst cloneUser = deepClone(user);\n\nconsole.log(user); // { name: 'xjq', height: 180 }\n\ndelete cloneUser.height;\nconsole.log(cloneUser); // { name: 'xjq' }\nconsole.log(user; // { name: 'xjq', height: 180 }\n```\n","desc":"实现对象深拷贝, 修改深拷贝对象不影响原对象","index":"/**\n * 深拷贝\n *\n * @param {*} obj\n * @return {*}\n */\nexport default function deepClone(obj) {\n  return {};\n}\n","test":"import assert from 'assert';\nimport _deepClone from './answer.mjs';\nimport f from './index.mjs';\n\nconst circle1 = { foo: 1 };\nconst circle2 = { bar: 2, c1: circle1 };\ncircle1.c2 = circle2;\n\nconst cases = [\n  {\n    Input: [{ f: 1 }],\n    Expected: [{ f: 1 }],\n    Message: '一层对象',\n  },\n  {\n    Input: [1, 2, { a: 1 }],\n    Expected: [1, 2, { a: 1 }],\n    Message: '两层对象',\n  },\n  {\n    Input: { b: [{ c: 1, d: [{ d: 1, f: 2 }] }] },\n    Expected: { b: [{ c: 1, d: [{ d: 1, f: 2 }] }] },\n    Message: '两层对象, 且修改返回值属性',\n    callback: function (i) {\n      const originInput = _deepClone(this.Input);\n      try {\n        const output = f(this.Input);\n        output['1'] = Math.random();\n        assert.deepEqual(this.Input, originInput);\n        return true;\n      } catch (error) {\n        if (error.code === 'ERR_ASSERTION') {\n          console.log(\n            '用例 ' + String(i + 1) + ': ' + this.Message + ' 未通过 ×'\n          );\n          console.log(\n            '修改输出对象属性后的输入对象: ',\n            JSON.stringify(this.Input)\n          );\n          console.log('原输入对象: ', JSON.stringify(originInput));\n        } else {\n          console.log(error);\n        }\n      }\n    },\n  },\n  {\n    Input: circle1,\n    Expected: { foo: 1, c2: { bar: 2, c1: {} } },\n    Message: '存在循环引用',\n    callback: function (i) {\n      try {\n        const output = f(this.Input);\n        assert.deepEqual(output, this.Expected);\n        return true;\n      } catch (error) {\n        console.log(\n          '用例 ' + String(i + 1) + ': ' + this.Message + ' 未通过 ×'\n        );\n        console.log(error);\n      }\n    },\n  },\n];\n\n(function () {\n  for (let i = 0; i < cases.length; i++) {\n    const { Input, Expected, Message, callback } = cases[i];\n    if (callback) {\n      if (!cases[i].callback(i)) {\n        break;\n      }\n    } else {\n      let output;\n      try {\n        output = f(Input);\n        assert.deepEqual(output, Expected);\n      } catch (error) {\n        console.log('用例 ' + String(i + 1) + ': ' + Message + ' 未通过 ×');\n        if (error.code === 'ERR_ASSERTION') {\n          console.log('Input:', JSON.stringify(Input));\n          console.log('Expected:', JSON.stringify(error.expected));\n          console.log('Received:', JSON.stringify(output));\n        } else {\n          console.log(error);\n        }\n        break;\n      }\n    }\n\n    console.log('用例 ' + String(i + 1) + ': ' + Message + ' 通过 √');\n  }\n})();\n"},"flatten":{"answer":"export default function flatten(arr) {\n  return arr.reduce((acc, cur) => {\n    if (Array.isArray(cur)) {\n      acc = acc.concat(flatten(cur));\n    } else {\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n}\n","introduce":"## Flatten\n\n实现数组扁平化方法\n\n用例 1:\n\n```js\nflatten([1, 2, 3]); // [1, 2, 3]\n```\n\n用例 2:\n\n```js\nflatten([1, [2, 3]]); // [1, 2, 3]\n```\n\n用例 3:\n\n```js\nflatten([1, [[2, 2], [3, [4]], 5]]); // [1, 2, 2, 3, 4, 5];\n```\n","desc":"实现数组扁平化方法","index":"/**\n * 扁平化\n *\n * @param {*} arr\n * @return {*}\n */\nexport default function flatten(arr) {\n  return [];\n}\n","test":"import assert from 'assert';\nimport f from './index.mjs';\n\nconst cases = [\n  {\n    Input: [1, 2, 3],\n    Expected: [1, 2, 3],\n    Message: '一层数组',\n  },\n  {\n    Input: [1, [2, 3]],\n    Expected: [1, 2, 3],\n    Message: '两层数组',\n  },\n  {\n    Input: [1, [[2, 2], [3, [4]], 5]],\n    Expected: [1, 2, 2, 3, 4, 5],\n    Message: '四层数组',\n  },\n];\n\n(function () {\n  for (let i = 0; i < cases.length; i++) {\n    const { Input, Expected, Message } = cases[i];\n    let output;\n    try {\n      output = f(Input);\n      assert.deepEqual(output, Expected);\n    } catch (error) {\n      console.log('用例 ' + String(i + 1) + ': ' + Message + ' 未通过 ×');\n      if (error.code === 'ERR_ASSERTION') {\n        console.log('Input:', JSON.stringify(Input));\n        console.log('Expected:', JSON.stringify(error.expected));\n        console.log('Received:', JSON.stringify(output));\n      } else {\n        console.log(error);\n      }\n      break;\n    }\n    console.log('用例 ' + String(i + 1) + ': ' + Message + ' 通过 √');\n  }\n})();\n"},"unique":{"answer":"export default function unique(arr) {\n  return [...new Set(arr)];\n}\n","introduce":"## Unique\n\n数组去重\n\n用例 1:\n\n```js\nconst arr = [1, 2, 3];\nconst uniqueArr = unique(arr1);\n\nconsole.log(uniqueArr); // [1, 2, 3]\n```\n\n用例 2:\n\n```js\nconst arr = [1, 2, 3, 3, 3];\nconst uniqueArr = unique(arr);\n\nconsole.log(uniqueArr); // [1, 2, 3]\n```\n","desc":"数组去重","index":"export default function unique(arr) {\n  return [];\n}\n","test":"import assert from 'assert';\nimport f from './index.mjs';\n\nconst cases = [\n  {\n    Input: [1, 2, 3],\n    Expected: [1, 2, 3],\n    Message: '无重复数字',\n  },\n  {\n    Input: [1, 2, 3, 3],\n    Expected: [1, 2, 3],\n    Message: '单个重复数字',\n  },\n  {\n    Input: [1, 1, 2, 2, 2, 3, 3],\n    Expected: [1, 2, 3],\n    Message: '多个重复数字',\n  },\n];\n\n(function () {\n  for (let i = 0; i < cases.length; i++) {\n    const { Input, Expected, Message } = cases[i];\n    let output;\n    try {\n      output = f(Input);\n      assert.deepEqual(output, Expected);\n    } catch (error) {\n      console.log('用例 ' + String(i + 1) + ': ' + Message + ' 未通过');\n      if (error.code === 'ERR_ASSERTION') {\n        console.log('Input:', JSON.stringify(Input));\n        console.log('Expected:', JSON.stringify(error.expected));\n        console.log('Received:', JSON.stringify(output));\n      } else {\n        console.log(error);\n      }\n      break;\n    }\n    console.log('用例 ' + String(i + 1) + ': ' + Message + ' 通过');\n  }\n})();\n"}}